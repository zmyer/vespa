// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
package com.yahoo.vespa.hosted.node.maintainer;

import com.yahoo.collections.Pair;
import static com.yahoo.vespa.defaults.Defaults.getDefaults;
import com.yahoo.system.ProcessExecuter;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * @author freva
 */
public class CoreCollectorTest {
    private final ProcessExecuter processExecuter = mock(ProcessExecuter.class);
    private final CoreCollector coreCollector = new CoreCollector(processExecuter);

    private final Path INSTALL_STATE_PATH = Paths.get("/path/to/install.state");
    private final Path TEST_CORE_PATH = Paths.get("/tmp/core.1234");
    private final Path TEST_BIN_PATH = Paths.get("/usr/bin/program");
    private final List<String> GDB_BACKTRACE = Arrays.asList("[New Thread 2703]",
            "Core was generated by `/usr/bin/program\'.", "Program terminated with signal 11, Segmentation fault.",
            "#0  0x00000000004004d8 in main (argv=0x1) at main.c:4", "4\t    printf(argv[3]);",
            "#0  0x00000000004004d8 in main (argv=0x1) at main.c:4");

    private final List<String> INSTALL_STATE = Arrays.asList("package: some_package-0.0.2",
            "variable 'value'",
            "ca_file /path/to/ca.pem");

    private final List<String> RPM_PACKAGES = Arrays.asList("some_package-0.0.2",
            "another_package-1.0.6",
            "last_pkg-3.10_102");

    @Rule
    public TemporaryFolder folder= new TemporaryFolder();

    private void mockExec(String[] cmd, String output) throws IOException, InterruptedException {
        mockExec(cmd, output, "");
    }

    private void mockExec(String[] cmd, String output, String error) throws IOException, InterruptedException {
        when(processExecuter.exec(cmd)).thenReturn(new Pair<>(error.isEmpty() ? 0 : 1, output + error));
    }

    static final String GDB_PATH = getDefaults().underVespaHome("bin64/gdb");

    @Test
    public void extractsBinaryPathTest() throws IOException, InterruptedException {
        final String[] cmd = {"file", TEST_CORE_PATH.toString()};

        mockExec(cmd,
                "/tmp/core.1234: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from " +
                        "'/usr/bin/program'");
        assertEquals(TEST_BIN_PATH, coreCollector.readBinPath(TEST_CORE_PATH));

        mockExec(cmd,
                "/tmp/core.1234: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from " +
                        "'/usr/bin/program --foo --bar baz'");
        assertEquals(TEST_BIN_PATH, coreCollector.readBinPath(TEST_CORE_PATH));

        mockExec(cmd,
                "/tmp/core.1234: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from " +
                        "'/usr/bin//program'");
        assertEquals(TEST_BIN_PATH, coreCollector.readBinPath(TEST_CORE_PATH));

        mockExec(cmd,
                "/tmp/core.1234: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, " +
                        "from 'program', real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, " +
                        "execfn: '/usr/bin/program', platform: 'x86_64");
        assertEquals(TEST_BIN_PATH, coreCollector.readBinPath(TEST_CORE_PATH));


        Path fallbackResponse = Paths.get("/response/from/fallback");
        mockExec(new String[]{"/bin/sh", "-c", GDB_PATH + " -n -batch -core /tmp/core.1234 | grep '^Core was generated by'"},
                "Core was generated by `/response/from/fallback'.");
        mockExec(cmd,
                "/tmp/core.1234: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style");
        assertEquals(fallbackResponse, coreCollector.readBinPath(TEST_CORE_PATH));

        mockExec(cmd, "", "Error code 1234");
        assertEquals(fallbackResponse, coreCollector.readBinPath(TEST_CORE_PATH));
    }

    @Test
    public void extractsBinaryPathUsingGdbTest() throws IOException, InterruptedException {
        final String[] cmd = new String[]{"/bin/sh", "-c",
                GDB_PATH + " -n -batch -core /tmp/core.1234 | grep '^Core was generated by'"};

        mockExec(cmd, "Core was generated by `/usr/bin/program-from-gdb --identity foo/search/cluster.content_'.");
        assertEquals(Paths.get("/usr/bin/program-from-gdb"), coreCollector.readBinPathFallback(TEST_CORE_PATH));

        mockExec(cmd, "", "Error 123");
        try {
            coreCollector.readBinPathFallback(TEST_CORE_PATH);
            fail("Expected not to be able to get bin path");
        } catch (RuntimeException e) {
            assertEquals("Failed to extract binary path from GDB, result: (1,Error 123), command: " +
                    "[/bin/sh, -c, /opt/vespa/bin64/gdb -n -batch -core /tmp/core.1234 | grep '^Core was generated by']", e.getMessage());
        }
    }

    @Test
    public void extractsBacktraceUsingGdb() throws IOException, InterruptedException {
        mockExec(new String[]{GDB_PATH, "-n", "-ex", "bt", "-batch", "/usr/bin/program", "/tmp/core.1234"},
                String.join("\n", GDB_BACKTRACE));
        assertEquals(GDB_BACKTRACE, coreCollector.readBacktrace(TEST_CORE_PATH, TEST_BIN_PATH, false));

        mockExec(new String[]{GDB_PATH, "-n", "-ex", "bt", "-batch", "/usr/bin/program", "/tmp/core.1234"},
                "", "Failure");
        try {
            coreCollector.readBacktrace(TEST_CORE_PATH, TEST_BIN_PATH, false);
            fail("Expected not to be able to read backtrace");
        } catch (RuntimeException e) {
            assertEquals("Failed to read backtrace (1,Failure), Command: " +
                    "[/opt/vespa/bin64/gdb, -n, -ex, bt, -batch, /usr/bin/program, /tmp/core.1234]", e.getMessage());
        }
    }

    @Test
    public void extractsBacktraceFromAllThreadsUsingGdb() throws IOException, InterruptedException {
        mockExec(new String[]{GDB_PATH, "-n", "-ex", "thread apply all bt", "-batch",
                        "/usr/bin/program", "/tmp/core.1234"},
                String.join("\n", GDB_BACKTRACE));
        assertEquals(GDB_BACKTRACE, coreCollector.readBacktrace(TEST_CORE_PATH, TEST_BIN_PATH, true));
    }

    @Test
    public void collectsDataTest() throws IOException, InterruptedException {
        mockExec(new String[]{"file", TEST_CORE_PATH.toString()},
                "/tmp/core.1234: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from " +
                        "'/usr/bin/program'");
        mockExec(new String[]{GDB_PATH, "-n", "-ex", "bt", "-batch", "/usr/bin/program", "/tmp/core.1234"},
                String.join("\n", GDB_BACKTRACE));
        mockExec(new String[]{GDB_PATH, "-n", "-ex", "thread apply all bt", "-batch",
                        "/usr/bin/program", "/tmp/core.1234"},
                String.join("\n", GDB_BACKTRACE));
        mockExec(new String[]{"cat", INSTALL_STATE_PATH.toString()}, String.join("\n", INSTALL_STATE));
        mockExec(new String[]{"rpm", "-qa"}, String.join("\n", RPM_PACKAGES));

        Map<String, Object> expectedData = new HashMap<>();
        expectedData.put("bin_path", TEST_BIN_PATH.toString());
        expectedData.put("backtrace", new ArrayList<>(GDB_BACKTRACE));
        expectedData.put("backtrace_all_threads", new ArrayList<>(GDB_BACKTRACE));
        expectedData.put("yinst_state", new ArrayList<>(INSTALL_STATE));
        expectedData.put("rpm_packages", new ArrayList<>(RPM_PACKAGES));
        assertEquals(expectedData, coreCollector.collect(TEST_CORE_PATH, Optional.of(INSTALL_STATE_PATH)));
    }

    @Test
    public void collectsPartialIfUnableToDetermineDumpingProgramTest() throws IOException, InterruptedException {
        // We fail to get backtrace and RPM packages, but install state works, make sure it is returned
        mockExec(new String[]{"cat", INSTALL_STATE_PATH.toString()}, String.join("\n", INSTALL_STATE));

        Map<String, Object> expectedData = new HashMap<>();
        expectedData.put("yinst_state", new ArrayList<>(INSTALL_STATE));
        assertEquals(expectedData, coreCollector.collect(TEST_CORE_PATH, Optional.of(INSTALL_STATE_PATH)));
    }

    @Test
    public void collectsPartialIfBacktraceFailsTest() throws IOException, InterruptedException {
        mockExec(new String[]{"file", TEST_CORE_PATH.toString()},
                "/tmp/core.1234: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from " +
                        "'/usr/bin/program'");
        mockExec(new String[]{GDB_PATH + " -n -ex bt -batch /usr/bin/program /tmp/core.1234"},
                "", "Failure");

        Map<String, Object> expectedData = new HashMap<>();
        expectedData.put("bin_path", TEST_BIN_PATH.toString());
        assertEquals(expectedData, coreCollector.collect(TEST_CORE_PATH, Optional.empty()));
    }

    @Test
    public void parseTotalMemoryTestTest() throws IOException {
        String memInfo = "MemTotal:   100000000 kB\nMemUsed:   1000000 kB\n";
        assertEquals(100000000, coreCollector.parseTotalMemorySize(memInfo));

        String badMemInfo = "This string has no memTotal value";
        try {
            coreCollector.parseTotalMemorySize(badMemInfo);
            fail("Expected to fail on parsing");
        } catch (RuntimeException e) {
            assertEquals("Could not parse meminfo: " + badMemInfo, e.getMessage());
        }
    }

    @Test
    public void testDeleteUncompressedFiles() throws IOException {
        final String documentId = "UIDD-ABCD-EFGH";
        final String coreDumpFilename = "core.dump";

        Path coredumpPath = folder.newFolder("crash").toPath()
                .resolve(CoredumpHandler.PROCESSING_DIRECTORY_NAME)
                .resolve(documentId);
        coredumpPath.toFile().mkdirs();
        coredumpPath.resolve(coreDumpFilename).toFile().createNewFile();

        Set<Path> expectedContentsOfCoredump = new HashSet<>(Arrays.asList(
                coredumpPath.resolve(CoredumpHandler.METADATA_FILE_NAME),
                coredumpPath.resolve(coreDumpFilename + ".lz4")));
        expectedContentsOfCoredump.forEach(path -> {
            try {
                path.toFile().createNewFile();
            } catch (IOException ignored) { ignored.printStackTrace();}
        });
        coreCollector.deleteDecompressedCoredump(coredumpPath.resolve(coreDumpFilename));

        assertEquals(expectedContentsOfCoredump, Files.list(coredumpPath).collect(Collectors.toSet()));
    }

    @Test
    public void testDeleteUncompressedFilesWithoutLz4() throws IOException {
        final String documentId = "UIDD-ABCD-EFGH";
        final String coreDumpFilename = "core.dump";

        Path coredumpPath = folder.newFolder("crash").toPath()
                .resolve(CoredumpHandler.PROCESSING_DIRECTORY_NAME)
                .resolve(documentId);
        coredumpPath.toFile().mkdirs();

        Set<Path> expectedContentsOfCoredump = new HashSet<>(Arrays.asList(
                coredumpPath.resolve(CoredumpHandler.METADATA_FILE_NAME),
                coredumpPath.resolve(coreDumpFilename)));
        expectedContentsOfCoredump.forEach(path -> {
            try {
                path.toFile().createNewFile();
            } catch (IOException ignored) { ignored.printStackTrace();}
        });
        coreCollector.deleteDecompressedCoredump(coredumpPath.resolve(coreDumpFilename));

        assertEquals(expectedContentsOfCoredump, Files.list(coredumpPath).collect(Collectors.toSet()));
    }
}
