// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
/**
 * When this file is changed, do "mvn generate-sources" to rebuild the parser.
 *
 * @author  bratseth
 */
options {
    CACHE_TOKENS       = true;
    STATIC             = false;
    DEBUG_PARSER       = false;
    USER_TOKEN_MANAGER = false;
    ERROR_REPORTING    = true;
    USER_CHAR_STREAM   = false;
}

PARSER_BEGIN(RankingExpressionParser)

package com.yahoo.searchlib.rankingexpression.parser;

import com.yahoo.searchlib.rankingexpression.rule.*;
import com.yahoo.searchlib.rankingexpression.evaluation.Value;
import com.yahoo.searchlib.rankingexpression.evaluation.StringValue;
import com.yahoo.searchlib.rankingexpression.evaluation.TensorValue;
import com.yahoo.tensor.*;
import com.yahoo.tensor.functions.*;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class RankingExpressionParser {

}

PARSER_END(RankingExpressionParser)

SKIP :
{
    <[" ","\n","\r","\t"]>
}

TOKEN :
{
    <INTEGER: <DECIMAL> (["l","L"])? | <HEX> (["l","L"])? | <OCTAL> (["l","L"])?> |
        <#DECIMAL: ["1"-"9"] (["0"-"9"])*> |
        <#HEX: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+> |
        <#OCTAL: "0" (["0"-"7"])*> |
    <FLOAT: (["0"-"9"])+ ("." (["0"-"9"])*)? (<EXPONENT>)? (["f","F","d","D"])?> |
        <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
}

TOKEN :
{
    <LBRACE: "("> |
    <RBRACE: ")"> |
    <LSQUARE: "["> |
    <RSQUARE: "]"> |
    <LCURLY: "{"> |
    <RCURLY: "}"> |

    <ADD: "+"> |
    <SUB: "-"> |
    <DIV: "/"> |
    <MUL: "*"> |
    <DOT: "."> |
    <MOD: "%"> |
    <POWOP: "^"> |

    <DOLLAR: "$"> |
    <COMMA: ","> |
    <COLON: ":"> |

    <LE: "<="> |
    <LT: "<"> |
    <EQ: "=="> |
    <NQ: "!="> |
    <AQ: "~="> |
    <GE: ">="> |
    <GT: ">"> |

    <STRING: ("\"" (~["\""] | "\\\"")* "\"") |
             ("'" (~["'"] | "\\'")* "'")> |

    <IF: "if"> |
    <IN: "in"> |
    <F: "f"> |

    <NOT: "!"> |
    <AND: "&&"> |
    <OR: "||"> |

    <ABS: "abs"> |
    <ACOS: "acos"> |
    <ASIN: "asin"> |
    <ATAN: "atan"> |
    <CEIL: "ceil"> |
    <COS: "cos"> |
    <COSH: "cosh"> |
    <ELU: "elu"> |
    <EXP: "exp"> |
    <FABS: "fabs"> |
    <FLOOR: "floor"> |
    <ISNAN: "isNan"> |
    <LOG: "log"> |
    <LOG10: "log10"> |
    <RELU: "relu"> |
    <ROUND: "round"> |
    <SIGMOID: "sigmoid"> |
    <SIGN: "sign"> |
    <SIN: "sin"> |
    <SINH: "sinh"> |
    <SQUARE: "square"> |
    <SQRT: "sqrt"> |
    <TAN: "tan"> |
    <TANH: "tanh"> |

    <ATAN2: "atan2"> |
    <FMOD: "fmod"> |
    <LDEXP: "ldexp"> |
    // MAX
    // MIN
    <POW: "pow"> |

    <MAP: "map"> |
    <REDUCE: "reduce"> |
    <JOIN: "join"> |
    <RENAME: "rename"> |
    <CONCAT: "concat"> |
    <TENSOR: "tensor"> |
    <RANGE: "range"> |
    <DIAG: "diag"> |
    <RANDOM: "random"> |
    <L1_NORMALIZE: "l1_normalize"> |
    <L2_NORMALIZE: "l2_normalize"> |
    <MATMUL: "matmul"> |
    <SOFTMAX: "softmax"> |
    <XW_PLUS_B: "xw_plus_b"> |
    <ARGMAX: "argmax"> |
    <ARGMIN: "argmin"> |

    <AVG: "avg" > |
    <COUNT: "count"> |
    <PROD: "prod"> |
    <SUM: "sum"> |
    <MAX: "max"> |
    <MIN: "min"> |

    <IDENTIFIER: (["A"-"Z","a"-"z","0"-"9","_","@"](["A"-"Z","a"-"z","0"-"9","_","@","$"])*)>
}

// Declare a special skip token for comments.
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* >
}

List<ReferenceNode> featureList() :
{
    List<ReferenceNode> ret = new ArrayList<ReferenceNode>();
    ReferenceNode exp;
}
{
    ( ( exp = feature() { ret.add(exp); } )+ <EOF> )
    { return ret; }
}

ExpressionNode rankingExpression() :
{
    ExpressionNode ret;
}
{
    ( ret = expression() <EOF> )
    { return ret; }
}

ExpressionNode expression() :
{
    ExpressionNode left, right;
    List<ExpressionNode> rightList;
    TruthOperator      comparatorOp;
}
{
    ( left = arithmeticExpression()
      (
          ( comparatorOp = comparator() right = arithmeticExpression() { left = new ComparisonNode(left, comparatorOp, right); } ) |
          ( <IN>           rightList = expressionList() { left =  new SetMembershipNode(left, rightList); }           )
      ) *
    )
    { return left; }
}

ExpressionNode arithmeticExpression() :
{
    ExpressionNode left, right = null;
    ArithmeticOperator arithmeticOp;
}
{
    ( left = value()
      ( arithmeticOp = arithmetic() right = value() { left = ArithmeticNode.resolve(left, arithmeticOp, right); } ) *
    )
    { return left; }
}

ArithmeticOperator arithmetic() : { }
{
    ( <ADD>   { return ArithmeticOperator.PLUS;     } |
      <SUB>   { return ArithmeticOperator.MINUS;    } |
      <DIV>   { return ArithmeticOperator.DIVIDE;   } |
      <MUL>   { return ArithmeticOperator.MULTIPLY; } |
      <MOD>   { return ArithmeticOperator.MODULO; }   |
      <AND>   { return ArithmeticOperator.AND; }      |
      <OR>    { return ArithmeticOperator.OR; }       |
      <POWOP> { return ArithmeticOperator.POWER; } )
    { return null; }
}

TruthOperator comparator() : { }
{
     ( <LE> { return TruthOperator.SMALLEREQUAL; } |
       <LT> { return TruthOperator.SMALLER;      } |
       <EQ> { return TruthOperator.EQUAL;        } |
       <NQ> { return TruthOperator.NOTEQUAL;     } |
       <AQ> { return TruthOperator.APPROX_EQUAL; } |
       <GE> { return TruthOperator.LARGEREQUAL;  } |
       <GT> { return TruthOperator.LARGER;       } )
     { return null; }
}

ExpressionNode value() :
{
    ExpressionNode ret;
    boolean neg = false;
    boolean not = false;
}
{
    (
      [ <NOT>                                               { not = true; } ]
      [ LOOKAHEAD(2) <SUB>                                  { neg = true; } ]
      (            ret = constantPrimitive()                                |
                   LOOKAHEAD(2) ret = ifExpression()                        |
                   LOOKAHEAD(4) ret = function()                            |
                   ret = feature()                                          |
                   ret = legacyQueryFeature()                               |
        ( <LBRACE> ret = expression() <RBRACE> { ret = new EmbracedNode(ret); } ) ) )
    {
        ret = not ? new NotNode(ret) : ret;
        ret = neg ? new NegativeNode(ret) : ret;
        return ret;
    }
}

IfNode ifExpression() :
{
    ExpressionNode condition, ifTrue, ifFalse;
    Double trueProbability = null;
}
{
    ( <IF> <LBRACE> ( condition =  expression() )
      <COMMA> ifTrue = expression() <COMMA> ifFalse = expression() ( <COMMA> trueProbability = doubleNumber() )? <RBRACE> )
    {
        return new IfNode(condition, ifTrue, ifFalse, trueProbability);
    }
}

ReferenceNode feature() :
{
    List<ExpressionNode> args = null;
    String name, out = null;
}
{
    ( name = identifier() [ <LBRACE> args = args() <RBRACE> ] [ <DOT> out = outs() ] )
    { return new ReferenceNode(name, args, out); }
}

// Query features can be referenced as "$name" instead of "query(name)". TODO: Warn this is deprecated
ReferenceNode legacyQueryFeature() :
{
    String name;
}
{
    ( <DOLLAR> name = identifier() )
    { return new ReferenceNode("query", Arrays.asList((ExpressionNode)new NameNode(name)), null); }
}

String outs() :
{
    StringBuilder ret = new StringBuilder();
    String str;
}
{
    (   str = out() { ret.append(str);         }
      ( <DOT>       { ret.append(token.image); }
        str = out() { ret.append(str);         } )* )
    { return ret.toString(); }
}

String out() :
{
    Function fnc;
    String name;
}
{
    ( <INTEGER>                  { return token.image;    } |
      <FLOAT>                    { return token.image;    } |
      name = identifier()        { return name; }           )
    { return null; }
}

List<ExpressionNode> args() :
{
    List<ExpressionNode> arguments = new ArrayList<ExpressionNode>();
    ExpressionNode argument;
}
{
    ( argument = arg() { arguments.add(argument); } ( <COMMA> argument = arg() { arguments.add(argument); } )* )
    { return arguments; }
}

// TODO: Replace use of this for macro arguments with value()
// For that to work with the current search execution framework
// we need to generate another macro for the argument such that we can replace
// instances of the argument with the reference to that macro in the same way
// as we replace by constants/names today (this can make for some fun combinatorial explosion).
// Simon also points out that we should stop doing macro expansion in the toString of a macro.
// - Jon 2014-05-02
ExpressionNode arg() :
{
    ExpressionNode ret;
    String name;
    Function fnc;
}
{
    ( ret = constantPrimitive()                                          |
      LOOKAHEAD(2) ret = feature()                                       |
      name = identifier()              { ret = new NameNode(name);       } )
    { return ret; }
}

ExpressionNode function() :
{
    ExpressionNode function;
}
{
    ( LOOKAHEAD(2) function = scalarOrTensorFunction() | function = tensorFunction() )
    { return function; }
}

FunctionNode scalarOrTensorFunction() :
{
    Function function;
    ExpressionNode arg1, arg2;
}
{
    (
      ( function = unaryFunctionName() <LBRACE> arg1 = expression() <RBRACE> )
      { return new FunctionNode(function, arg1); }
    ) |
    (
      ( function = binaryFunctionName() <LBRACE> arg1 = expression() <COMMA> arg2 = expression() <RBRACE> )
      { return new FunctionNode(function, arg1, arg2); }
    )
}

ExpressionNode tensorFunction() :
{
    ExpressionNode tensorExpression;
}
{
    (
        tensorExpression = tensorMap() |
        tensorExpression = tensorReduce() |
        tensorExpression = tensorReduceComposites() |
        tensorExpression = tensorJoin() |
        tensorExpression = tensorRename() |
        tensorExpression = tensorConcat() |
        tensorExpression = tensorGenerate() |
        tensorExpression = tensorRange() |
        tensorExpression = tensorDiag() |
        tensorExpression = tensorRandom() |
        tensorExpression = tensorL1Normalize() |
        tensorExpression = tensorL2Normalize() |
        tensorExpression = tensorMatmul() |
        tensorExpression = tensorSoftmax() |
        tensorExpression = tensorXwPlusB() |
        tensorExpression = tensorArgmax() |
        tensorExpression = tensorArgmin()
    )
    { return tensorExpression; }
}

ExpressionNode tensorMap() :
{
    ExpressionNode tensor;
    LambdaFunctionNode doubleMapper;
}
{
    <MAP> <LBRACE> tensor = expression() <COMMA> doubleMapper = lambdaFunction() <RBRACE>
    { return new TensorFunctionNode(new Map(TensorFunctionNode.wrapArgument(tensor),
                                            doubleMapper.asDoubleUnaryOperator())); }
}

ExpressionNode tensorReduce() :
{
    ExpressionNode tensor;
    Reduce.Aggregator aggregator;
    List<String> dimensions = null;
}
{
    <REDUCE> <LBRACE> tensor = expression() <COMMA> aggregator = tensorReduceAggregator() dimensions = tagCommaLeadingList() <RBRACE>
    { return new TensorFunctionNode(new Reduce(TensorFunctionNode.wrapArgument(tensor), aggregator, dimensions)); }
}

ExpressionNode tensorReduceComposites() :
{
    ExpressionNode tensor;
    Reduce.Aggregator aggregator;
    List<String> dimensions = null;
}
{
    aggregator = tensorReduceAggregator()
    <LBRACE> tensor = expression() dimensions = tagCommaLeadingList() <RBRACE>
    { return new TensorFunctionNode(new Reduce(TensorFunctionNode.wrapArgument(tensor), aggregator, dimensions)); }
}

ExpressionNode tensorJoin() :
{
    ExpressionNode tensor1, tensor2;
    LambdaFunctionNode doubleJoiner;
}
{
    <JOIN> <LBRACE> tensor1 = expression() <COMMA> tensor2 = expression() <COMMA> doubleJoiner = lambdaFunction() <RBRACE>
    { return new TensorFunctionNode(new Join(TensorFunctionNode.wrapArgument(tensor1),
                                             TensorFunctionNode.wrapArgument(tensor2),
                                             doubleJoiner.asDoubleBinaryOperator())); }
}

ExpressionNode tensorRename() :
{
    ExpressionNode tensor;
    List<String> fromDimensions, toDimensions;
}
{
    <RENAME> <LBRACE> tensor = expression() <COMMA>
                      fromDimensions = bracedIdentifierList() <COMMA>
                      toDimensions = bracedIdentifierList()
             <RBRACE>
    { return new TensorFunctionNode(new Rename(TensorFunctionNode.wrapArgument(tensor), fromDimensions, toDimensions)); }
}

ExpressionNode tensorConcat() :
{
    ExpressionNode tensor1, tensor2;
    String dimension;
}
{
    <CONCAT> <LBRACE> tensor1 = expression() <COMMA> tensor2 = expression() <COMMA> dimension = tag() <RBRACE>
    { return new TensorFunctionNode(new Concat(TensorFunctionNode.wrapArgument(tensor1),
                                               TensorFunctionNode.wrapArgument(tensor2),
                                               dimension)); }
}

ExpressionNode tensorGenerate() :
{
    TensorType type;
    ExpressionNode generator;
}
{
    <TENSOR> type = tensorTypeArgument() <LBRACE> generator = expression() <RBRACE>
    { return new TensorFunctionNode(new Generate(type, new GeneratorLambdaFunctionNode(type, generator).asLongListToDoubleOperator())); }
}

ExpressionNode tensorRange() :
{
    TensorType type;
}
{
    <RANGE> type = tensorTypeArgument()
    { return new TensorFunctionNode(new Range(type)); }
}

ExpressionNode tensorDiag() :
{
    TensorType type;
}
{
    <DIAG> type = tensorTypeArgument()
    { return new TensorFunctionNode(new Diag(type)); }
}

ExpressionNode tensorRandom() :
{
    TensorType type;
}
{
    <RANDOM> type = tensorTypeArgument()
    { return new TensorFunctionNode(new Random(type)); }
}

ExpressionNode tensorL1Normalize() :
{
    ExpressionNode tensor;
    String dimension;
}
{
    <L1_NORMALIZE> <LBRACE> tensor = expression() <COMMA> dimension = identifier() <RBRACE>
    { return new TensorFunctionNode(new L1Normalize(TensorFunctionNode.wrapArgument(tensor), dimension)); }
}

ExpressionNode tensorL2Normalize() :
{
    ExpressionNode tensor;
    String dimension;
}
{
    <L2_NORMALIZE> <LBRACE> tensor = expression() <COMMA> dimension = identifier() <RBRACE>
    { return new TensorFunctionNode(new L2Normalize(TensorFunctionNode.wrapArgument(tensor), dimension)); }
}

ExpressionNode tensorMatmul() :
{
    ExpressionNode tensor1, tensor2;
    String dimension;
}
{
    <MATMUL> <LBRACE> tensor1 = expression() <COMMA> tensor2 = expression() <COMMA> dimension = identifier() <RBRACE>
    { return new TensorFunctionNode(new Matmul(TensorFunctionNode.wrapArgument(tensor1),
                                               TensorFunctionNode.wrapArgument(tensor2),
                                               dimension)); }
}

ExpressionNode tensorSoftmax() :
{
    ExpressionNode tensor;
    String dimension;
}
{
    <SOFTMAX> <LBRACE> tensor = expression() <COMMA> dimension = identifier() <RBRACE>
    { return new TensorFunctionNode(new Softmax(TensorFunctionNode.wrapArgument(tensor), dimension)); }
}

ExpressionNode tensorXwPlusB() :
{
    ExpressionNode tensor1, tensor2, tensor3;
    String dimension;
}
{
    <XW_PLUS_B> <LBRACE> tensor1 = expression() <COMMA>
                         tensor2 = expression() <COMMA>
                         tensor3 = expression() <COMMA>
                         dimension = identifier() <RBRACE>
    { return new TensorFunctionNode(new XwPlusB(TensorFunctionNode.wrapArgument(tensor1),
                                                TensorFunctionNode.wrapArgument(tensor2),
                                                TensorFunctionNode.wrapArgument(tensor3),
                                                dimension)); }
}

ExpressionNode tensorArgmax() :
{
    ExpressionNode tensor;
    String dimension;
}
{
    <ARGMAX> <LBRACE> tensor = expression() <COMMA> dimension = identifier() <RBRACE>
    { return new TensorFunctionNode(new Argmax(TensorFunctionNode.wrapArgument(tensor), dimension)); }
}

ExpressionNode tensorArgmin() :
{
    ExpressionNode tensor;
    String dimension;
}
{
    <ARGMIN> <LBRACE> tensor = expression() <COMMA> dimension = identifier() <RBRACE>
    { return new TensorFunctionNode(new Argmin(TensorFunctionNode.wrapArgument(tensor), dimension)); }
}

LambdaFunctionNode lambdaFunction() :
{
    List<String> variables;
    ExpressionNode functionExpression;
}
{
     ( <F> <LBRACE> variables = identifierList() <RBRACE> <LBRACE> functionExpression = expression() <RBRACE> )
     { return new LambdaFunctionNode(variables, functionExpression); }
}

Reduce.Aggregator tensorReduceAggregator() :
{
}
{
    ( <AVG> | <COUNT> | <PROD> | <SUM> | <MAX> | <MIN> )
    { return Reduce.Aggregator.valueOf(token.image); }
}

TensorType tensorTypeArgument() :
{
    TensorType.Builder builder = new TensorType.Builder();
}
{
    <LBRACE>
    ( tensorTypeDimension(builder) ) ?
    ( <COMMA> tensorTypeDimension(builder) ) *
    <RBRACE>
    { return builder.build(); }
}

// NOTE: Only indexed bound dimensions are parsed currently, as that is what we need
void tensorTypeDimension(TensorType.Builder builder) :
{
    String name;
    int size;
}
{
    name = identifier() <LSQUARE> size = integerNumber() <RSQUARE>
    { builder.indexed(name, size); }
}

// This is needed not to parse tensor functions but for the "reserved names as literals" workaround cludge
String tensorFunctionName() :
{
    Reduce.Aggregator aggregator;
}
{
    ( <F>            { return token.image; } ) |
    ( <MAP>          { return token.image; } ) |
    ( <REDUCE>       { return token.image; } ) |
    ( <JOIN>         { return token.image; } ) |
    ( <RENAME>       { return token.image; } ) |
    ( <CONCAT>       { return token.image; } ) |
    ( <TENSOR>       { return token.image; } ) |
    ( <RANGE>        { return token.image; } ) |
    ( <DIAG>         { return token.image; } ) |
    ( <RANDOM>       { return token.image; } ) |
    ( <L1_NORMALIZE> { return token.image; } ) |
    ( <L2_NORMALIZE> { return token.image; } ) |
    ( <MATMUL>       { return token.image; } ) |
    ( <SOFTMAX>      { return token.image; } ) |
    ( <XW_PLUS_B>    { return token.image; } ) |
    ( <ARGMAX>       { return token.image; } ) |
    ( <ARGMIN>       { return token.image; } ) |
    ( aggregator = tensorReduceAggregator() { return aggregator.toString(); } )
}

Function unaryFunctionName() : { }
{
    <ABS>     { return Function.abs;     } |
    <ACOS>    { return Function.acos;    } |
    <ASIN>    { return Function.asin;    } |
    <ATAN>    { return Function.atan;    } |
    <CEIL>    { return Function.ceil;    } |
    <COS>     { return Function.cos;     } |
    <COSH>    { return Function.cosh;    } |
    <ELU>     { return Function.elu;     } |
    <EXP>     { return Function.exp;     } |
    <FABS>    { return Function.fabs;    } |
    <FLOOR>   { return Function.floor;   } |
    <ISNAN>   { return Function.isNan;   } |
    <LOG>     { return Function.log;     } |
    <LOG10>   { return Function.log10;   } |
    <RELU>    { return Function.relu;    } |
    <ROUND>   { return Function.round;   } |
    <SIGMOID> { return Function.sigmoid; } |
    <SIGN>    { return Function.sign;    } |
    <SIN>     { return Function.sin;     } |
    <SINH>    { return Function.sinh;    } |
    <SQUARE>  { return Function.square;  } |
    <SQRT>    { return Function.sqrt;    } |
    <TAN>     { return Function.tan;     } |
    <TANH>    { return Function.tanh;    }
}

Function binaryFunctionName() : { }
{
    <ATAN2> { return Function.atan2; } |
    <FMOD>  { return Function.fmod;  } |
    <LDEXP> { return Function.ldexp; } |
    <MAX>   { return Function.max;   } |
    <MIN>   { return Function.min;   } |
    <POW>   { return Function.pow;   }
}

List<ExpressionNode> expressionList() :
{
    List<ExpressionNode> list = new ArrayList<ExpressionNode>();
    ExpressionNode expression;
}
{
    <LSQUARE>
    expression=expression() { list.add(expression); }
    ( LOOKAHEAD(2) <COMMA> expression=expression() { list.add(expression); } ) *
    <RSQUARE>
    { return list; }
}

double doubleNumber() :
{
    String sign = "";
}
{
    ( <SUB> { sign = "-";} )? ( <FLOAT> | <INTEGER> )
    { return Double.parseDouble(sign + token.image); }
}

int integerNumber() :
{
    String sign = "";
}
{
    ( <SUB> { sign = "-";} )? ( <INTEGER> )
    { return Integer.parseInt(sign + token.image); }
}

String identifier() :
{
    String name;
    Function func;
}
{
    LOOKAHEAD(2) name = tensorFunctionName() { return name; }            |
    func = unaryFunctionName()  { return func.toString(); } |
    func = binaryFunctionName() { return func.toString(); } |
    <IF>                        { return token.image; }     |
    <IN>                        { return token.image; }     |
    <IDENTIFIER>                { return token.image; }
}

List<String> identifierList() :
{
    List<String> list = new ArrayList<String>();
    String element;
}
{
    ( element = identifier() { list.add(element); } )?
    ( <COMMA> element = identifier() { list.add(element); } ) *
    { return list; }
}

List<String> bracedIdentifierList() :
{
    List<String> list = new ArrayList<String>();
    String element;
}
{
    ( element = identifier() { return Collections.singletonList(element); } )
    |
    ( <LBRACE> list = identifierList() <RBRACE> { return list; } )
}

// An identifier or integer
String tag() :
{
    String name;
}
{
    name = identifier() { return name; } |
    <INTEGER> { return token.image; }
}

List<String> tagCommaLeadingList() :
{
    List<String> list = new ArrayList<String>();
    String element;
}
{
    ( <COMMA> element = tag() { list.add(element); } ) *
    { return list; }
}

ConstantNode constantPrimitive() :
{
    String sign = "";
    String value;
}
{
    ( <SUB> { sign = "-";} ) ?
    ( <INTEGER> { value = token.image; } |
      <FLOAT> { value = token.image; } |
      value = stringPath() )
    { return new ConstantNode(Value.parse(sign + value),sign + value); }
}

// Strings separated by "/"
String stringPath() :
{
    StringBuilder b = new StringBuilder();
}
{
    <STRING> { b.append(token.image); }
    ( LOOKAHEAD(2) <DIV> <STRING> { b.append("/").append(token.image); } ) *
    { return b.toString(); }
}

Value primitiveValue() :
{
    String sign = "";
}
{
    ( <SUB> { sign = "-";} ) ?
    ( <INTEGER> | <FLOAT> | <STRING> )
    { return Value.parse(sign + token.image); }
}
